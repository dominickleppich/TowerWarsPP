\section*{Spiel}
Realisieren Sie \textbf{BreaktroughPP} als Computerspiel in Java. Kommentieren Sie den Quellcode ausführlich. Verwenden Sie JavaDoc für das \emph{Application Programming Interface (API)} und kommentieren Sie sonst wie üblich. Verwenden Sie Ant zum automatisierten Übersetzen des Quelltextes und Erzeugen der Dokumentation.

\begin{enumerate}
\item Alle Klassen und Schnittstellen gehören zu einem Package, das mit \code{breakthroughPP} beginnt.

Bis auf die Schnittstelle \code{Viewer} dürfen die vorgegebenen Klassen und Schnittstellen des Package \code{breakthroughPP.preset}, mit Ausnahme von Kommentaren, nicht verändert werden.

Die vorgegebenen Quelltexte finden Sie in der Stud.IP-Veranstaltung unter \\
Dateien\textrightarrow Projekt\textrightarrow breakthroughPP.tgz
\item Erstellen Sie eine Spielbrett-Klasse mit folgenden Merkmalen.
\begin{itemize}
\item Ein Spielfeld mit $m \times n$ Feldern wird verwaltet. Dabei gelten $6 \le m \le 26$ und $2 \le n \le 26$.
\item Es wird eine Methode exportiert mit der Spielzüge entgegengenommen werden.
\item Gültige Spielzüge und Spielzüge die zum Ende des Spiels führen werden erkannt.

Ein leerer Zug (\code{null}) ist gültig und wird als Aufgabe des Spielers gewertet.
\item Der erste entgegengenommene Spielzug gehört immer zum roten Spieler.
\item Ein Spielzug ist ein Objekt der Klasse \code{breakthroughPP.preset.Move}, das mit Referenzen auf Objekte der Klasse \code{breaktroughPP.preset.Position} arbeitet.
\lstinputlisting{files/preset/Move.java}
\lstinputlisting{files/preset/Position.java}

\item Es wird eine Methode exportiert, die ein Objekt der Klasse\\ \code{breakthroughPP.preset.Status} zurückliefert, über die der Spielstand erfragt werden kann. Konstanten für den Status und die Spielerfarben sind in der Schnittstelle \code{breakthroughPP.preset.Setting} hinterlegt.
\lstinputlisting{files/preset/Status.java}

\item Es wird eine Methode exportiert, die -- ausgehend von der aktuellen Spielsituation -- alle möglichen gültigen Spielzüge eines Spielers zurückliefert.
\item Die Schnittstelle \code{breakthroughPP.preset.Viewable} wird implementiert.
%\lstinputlisting{files/shortened/Viewable.java}
\end{itemize}
\item Erstellen Sie eine Klasse, die die Schnittstelle \code{breakthroughPP.preset.Viewer} implementiert.
%\lstinputlisting{files/shortened/Viewer.java}
Diese Klasse soll es ermöglichen alle für das Anzeigen eines Spielbrett-Objekts nötigen Informationen zu erfragen, ohne Zugriff auf die Attribute des Spielbrett-Objekts zuzulassen.

Die Methode \code{viewer} des Spielbretts liefert ein passendes Objekt dieser Klasse.
\item Erstellen Sie eine Text-Ausgabe-Klasse mit der der aktuelle Spielstand eines Spielbretts auf die Standardausgabe geschrieben werden kann. Dazu wird ein Objekt einer Klasse, die die Schnittstelle \code{breakthroughPP.preset.Viewer} implementiert, benutzt.
\item Erstellen Sie eine Text-Eingabe-Klasse, die die Schnittstelle \\ \code{breakthroughPP.preset.Requestable} implementiert.
%\lstinputlisting{files/shortened/Requestable.java}
Die Methode \code{deliver} fordert einen Zug, in einer Zeile, von der Standardeingabe an und liefert ein dazu passendes \code{breakthroughPP.preset.Move}-Objekt zurück.
\item Alle Spieler implementieren die folgende Schnittstelle \code{breakthroughPP.preset.Player}.
\lstinputlisting{files/preset/Player.java}
\begin{itemize}[leftmargin=4em]
\item[\code{request}] \hfill \\Fordert vom Spieler einen Zug an.
\item[\code{confirm}] \hfill \\Übergibt dem Spieler im Parameter \code{boardStatus} Informationen über den letzten mit \code{request} vom Spieler gelieferten Zug.

\underline{Beispiele}
\begin{itemize}
\item Gilt \code{boardStatus.isOk()} war der letzte Zug gültig
\item Gilt \code{boardStatus.isRedWin()} war der letzte Zug gültig und der rote Spieler hat das Spiel gewonnen.
\end{itemize}
\item[\code{update}] \hfill \\Liefert dem Spieler im Parameter \code{opponentMove} den letzten Zug des Gegners und im Parameter \code{boardStatus} Informationen über diesen Zug.
\item[\code{init}] \hfill \\Initialisiert den Spieler, sodass mit diesem Spieler-Objekt ein neues Spiel mit einem Spielbrett \code{dimX} $\times$ \code{dimY} und der durch den Parameter \code{color} bestimmten Farbe, begonnen werden kann.
\end{itemize}

\underline{Weitere Anforderungen}
\begin{itemize}
\item Ein Spieler hat keine Referenz auf das Spielbrett-Objekt des Programmteils, der die Züge anfordert. Trotzdem muss ein Spieler den Spielverlauf dokumentieren, damit er gültige Züge identifizieren kann. Dazu erzeugt jeder Spieler ein eigenes Spielbrett-Objekt und setzt seine und die Züge des Gegenspielers auf diesem Brett.

Daraus können sich Widersprüche zwischen dem Status des eigenen Spielbretts und dem gelieferten Status ergeben. Das ist ein Fehler auf den mit einer Exception reagiert wird.

%NEW
Für ein problemloses Netzwerkspiel ist es nötig, dass alle Exceptions die in innerhalb der Spielerklassen geworfen werden keine Instanzen eigener Exceptionklassen sind. An jeder anderen Stelle im Spiel können eigene Exceptions frei erzeugt und geworfen werden.
\item Die Methoden der Player-Schnittstelle müssen in der richtige Reihenfolge aufgerufen werden. Eine Abweichung davon ist ein Fehler auf den mit einer Exception reagiert wird.
\end{itemize}
\item Erstellen Sie eine Interaktive-Spieler-Klasse, die die Schnittstelle \\ \code{breakthroughPP.preset.Player} implementiert.

Ein Interaktiver-Spieler benutzt ein Objekt der Text-Eingabe-Klasse um Züge vom Benutzer anzufordern.
\item Erstellen Sie eine ausführbare Klasse mit folgender Funktionalität.
\begin{itemize}
\item Es gibt eine Möglichkeit bei Ausführen der Klasse auf der Kommandozeile einen Debug-Schalter zu setzen und die Größe des Spielbretts zu übergeben.
\item Ein Spielbrett in Ausgangsposition wird initialisiert.
\item Zwei Objekte der Interaktive-Spieler-Klasse werden erzeugt und über Spieler-Schnittstellen-Referenzen angesprochen. 

Beide Spieler benutzen dasselbe Objekt der Text-Eingabe-Klasse um Züge vom Benutzer anzufordern.
\item Von den Spieler-Referenzen werden abwechselnd Züge erfragt. Gültige Züge werden bestätigt und dem jeweils anderen Spieler mitgeteilt.
\item Die gültigen Züge werden auf dem Spielbrett ausgeführt.

Ist der Debug-Schalter gesetzt, erfolgt nach jedem ausgeführten Zug eine Ausgabe des Spielbretts durch ein Objekt der Text-Ausgabe-Klasse.
\item Wenn ein Zug zum Spielende führt werden die Spieler darüber informiert und das Programm beendet.

Ist der Debug-Schalter gesetzt, wird das Ergebnis auf der Standardausgabe ausgegeben.
\end{itemize}
\item Erstellen Sie eine Computerspieler-Klasse, die die Spieler-Schnittstelle implementiert und gültige, aber nicht notwendigerweise zielgerichtete, Züge generiert. Dazu wird aus allen aktuell möglichen gültigen Spielzügen zufällig ein Zug ausgewählt.

Erweitern Sie die ausführbare Klasse so, dass Benutzer gegen den Computer und Computer gegen Computer spielen können. Das kann z.B. über Kommandozeilenparameter gesteuert werden.

\underline{Hinweis}

Java stellt für die Erzeugung von Pseudozufallszahlen die Klasse \code{java.util.Random} zur Verfügung.
\item Erstellen Sie einen weiteren Computerspieler, der zielgerichtet, entsprechend der unten beschriebenen einfachen Strategie, versucht das Spiel zu gewinnen.

Zusätzlich gelten die beiden folgenden Regeln.
\begin{enumerate}[label=\alph*)]
\item Gibt es einen Zug mit dem das Spiel gewonnen werden kann, dann wird dieser ausgeführt.
\item Ein Zug, der zur Folge hätte, dass der Gegner im nächsten Zug gewinnen könnte, wird nur ausgeführt, wenn es keine Alternative gibt.
\end{enumerate}
\item Erstellen Sie eine grafische Ein-Ausgabe-Klasse. Diese Klasse implementiert die Schnittstelle \code{breakthroughPP.preset.Requestable} und benutzt ein Objekt einer Klasse, die die Schnittstelle \code{breakthroughPP.preset.Viewer} implementiert, für eine einfache grafische Ausgabe.

Sorgen Sie dafür, dass man das Spiel Computer gegen Computer mit grafischer Ausgabe verfolgen kann, z.B. über einen Kommandozeilenparameter für eine Geschwindigkeitsreduzierung.

\underline{Hinweis}

Investieren Sie nicht zu viel Zeit in das Design, denn es wird nicht bewertet.
\item Programmieren Sie einen Netzwerkspieler mit dem sie jede Implementation der Schnittstelle \code{breakthroughPP.preset.Player} an eine andere BreakthroughPP-Implementation exportieren können.

Ein Gerüst für einen Netzwerkspieler finden Sie nachfolgend.
\begin{lstlisting}
package breakthroughPP.demo;

import java.rmi.*;
import java.rmi.server.UnicastRemoteObject;
import java.net.*;

import breakthroughPP.preset.*;

public class NetPlayer extends UnicastRemoteObject implements Player {
	public NetPlayer(Player player) throws RemoteException {
		this.player = player;
	}
	
	public Move request() throws Exception, RemoteException {
		return player.request();
	}
	
	public void update(Move opponentMove, Status boardStatus)
		throws Exception, RemoteException {
		player.update(opponentMove, boardStatus);
	}
	
	public void confirm(Status boardStatus)
		throws Exception, RemoteException {
		player.confirm(boardStatus);
	}		
	
	public void init(int dimX, int dimY, int color)
		throws Exception, RemoteException {
		player.init(dimX, dimY, color);	
	} 
	
	// ---------------------------------------------
	private Player player;
}
\end{lstlisting}
Erstellen Sie eine neue ausführbare Klasse, die Netzwerkspieler anbieten und finden kann, sowie den Spielablauf steuert und soweit nötig Objekte der Ein-Ausgabe-Klassen verwaltet. Duplizieren Sie dafür so wenig Quellcode wie möglich.

Die folgende Methode \code{offer} ist ein Beispiel wie ein Netzwerkspieler an einen Rechner \code{host}, auf dem eine RMI-Registry läuft, unter einem beliebigen Namen \code{name} angeboten werden kann.
\begin{lstlisting}
	public void offer(Player p, String host, String name) {
		try {
			Naming.rebind("rmi://" + host + "/" + name, p);
			System.out.println("Player (" + name + ") ready");
		} catch (MalformedURLException ex) {
			ex.printStackTrace();
		} catch (RemoteException ex) {
			ex.printStackTrace();
		}
	}
\end{lstlisting}
Die folgende Methode \code{find} ist ein Beispiel wie ein Spieler auf einen Rechner \code{host}, auf dem eine RMI-Registry läuft, unter einem bekannten Namen \code{name} gefunden werden kann.
\begin{lstlisting}
	public Player find(String host, String name) {
		Player p = null;
		try {
			p = (Player) Naming.lookup("rmi://" + host + "/" + name);
			System.out.println("Player (" + name + ") found");
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return p;
	}
\end{lstlisting}
\item \textbf{Optional.} Bauen Sie das Spiel weiter aus.
\begin{itemize}
\item Laden und Speichern von Spielständen
\item Erstellen Sie einen weiteren, intelligenteren Computerspieler, z.B. durch die Vorrausberechnung weiterer Züge und/oder einer besser balancierten und/oder erweiterten Bewertung.
\item \dots
\end{itemize}
\end{enumerate}

\textbf{Anforderungen an das fertige Projekt}
\begin{enumerate}
\item Per E-Mail an \code{brosenne@informatik.uni-goettingen.de} wird eine Anleitung und ein Archiv (tar, zip, etc.) ausgeliefert.
\item Das Archiv enthält den Quelltext des BreakthroughPP-Computerspiels, der sich im Rechnerpool des Instituts für Informatik übersetzen und starten lässt.

Es gibt ein Ant-Buildfile, das eine lauffähige Version des BreakthroughPP-Computerspiels, gepackt in ein Jar-File, und die vollständige API-Dokumentation erzeugen kann.
\item Die Anleitung beschreibt wie das Archiv zu entpacken ist, der Quelltext übersetzt, die API-Dokumentation erzeugt und das BreaktroughPP-Computerspiel gestartet wird. Weiterhin wird die Bedienung des Spiels beschrieben.
\end{enumerate}